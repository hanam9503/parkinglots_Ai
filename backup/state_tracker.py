"""
state_tracker.py - Vehicle State Management Module
==================================================
Qu·∫£n l√Ω tr·∫°ng th√°i c√°c xe trong c√°c √¥ ƒë·ªó
Theo d√µi l·ªãch s·ª≠ ph√°t hi·ªán v√† x√°c nh·∫≠n thay ƒë·ªïi tr·∫°ng th√°i
"""

import time
import threading
from collections import defaultdict, deque
from typing import Dict, Optional, Any, List
import logging

logger = logging.getLogger(__name__)

class VehicleStateTracker:
    """
    L·ªõp theo d√µi tr·∫°ng th√°i xe trong c√°c √¥ ƒë·ªó
    
    Ch·ª©c nƒÉng ch√≠nh:
    - Theo d√µi l·ªãch s·ª≠ ph√°t hi·ªán c·ªßa m·ªói √¥ ƒë·ªó
    - X√°c nh·∫≠n thay ƒë·ªïi tr·∫°ng th√°i d·ª±a tr√™n consistency
    - NgƒÉn ch·∫∑n false positive/negative
    - Qu·∫£n l√Ω timeout cho c√°c tr·∫°ng th√°i c≈©
    """
    
    def __init__(self, 
                 min_detections: int = 3,
                 max_history: int = 8,
                 consistency_threshold: float = 0.75,
                 state_timeout: int = 3600):
        """
        Kh·ªüi t·∫°o state tracker
        
        Args:
            min_detections (int): S·ªë l·∫ßn ph√°t hi·ªán t·ªëi thi·ªÉu ƒë·ªÉ x√°c nh·∫≠n tr·∫°ng th√°i
            max_history (int): S·ªë l∆∞·ª£ng detection history t·ªëi ƒëa l∆∞u tr·ªØ
            consistency_threshold (float): Ng∆∞·ª°ng consistency ƒë·ªÉ x√°c nh·∫≠n (0.0-1.0)
            state_timeout (int): Timeout cho tr·∫°ng th√°i (seconds)
        """
        self.min_detections = min_detections
        self.max_history = max_history
        self.consistency_threshold = consistency_threshold
        self.state_timeout = state_timeout
        
        # L·ªãch s·ª≠ ph√°t hi·ªán cho m·ªói √¥ ƒë·ªó
        # Format: spot_id -> deque([{occupied: bool, timestamp: float, car_id: str}])
        self.detection_history = defaultdict(lambda: deque(maxlen=max_history))
        
        # Tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n
        # Format: spot_id -> bool (True=occupied, False=empty)
        self.confirmed_states = {}
        
        # Timestamp c·ªßa l·∫ßn thay ƒë·ªïi tr·∫°ng th√°i cu·ªëi c√πng
        # Format: spot_id -> float
        self.state_timestamps = {}
        
        # Lock ƒë·ªÉ ƒë·∫£m b·∫£o thread safety
        self.lock = threading.RLock()
        
        logger.info(f"üîÑ VehicleStateTracker initialized with {min_detections} min detections")
    
    def update_detection(self, spot_id: str, is_occupied: bool, car_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        C·∫≠p nh·∫≠t ph√°t hi·ªán cho m·ªôt √¥ ƒë·ªó
        
        Args:
            spot_id (str): ID c·ªßa √¥ ƒë·ªó
            is_occupied (bool): C√≥ xe hay kh√¥ng
            car_id (str, optional): ID c·ªßa xe (n·∫øu c√≥)
            
        Returns:
            Dict ho·∫∑c None: Th√¥ng tin state change n·∫øu c√≥ thay ƒë·ªïi ƒë∆∞·ª£c x√°c nh·∫≠n
                {
                    'spot_id': str,
                    'new_state': bool,
                    'previous_state': bool,
                    'car_id': str,
                    'confidence': float,
                    'detection_count': int
                }
        """
        with self.lock:
            current_time = time.time()
            
            # Th√™m detection m·ªõi v√†o l·ªãch s·ª≠
            detection = {
                'occupied': is_occupied,
                'timestamp': current_time,
                'car_id': car_id
            }
            
            self.detection_history[spot_id].append(detection)
            
            # Ki·ªÉm tra xem c√≥ thay ƒë·ªïi tr·∫°ng th√°i kh√¥ng
            state_change = self._check_state_change(spot_id)
            
            return state_change
    
    def _check_state_change(self, spot_id: str) -> Optional[Dict[str, Any]]:
        """
        Ki·ªÉm tra xem c√≥ thay ƒë·ªïi tr·∫°ng th√°i ƒë∆∞·ª£c x√°c nh·∫≠n kh√¥ng
        
        Args:
            spot_id (str): ID √¥ ƒë·ªó c·∫ßn ki·ªÉm tra
            
        Returns:
            Dict ho·∫∑c None: Th√¥ng tin state change n·∫øu c√≥
        """
        history = self.detection_history[spot_id]
        
        # C·∫ßn √≠t nh·∫•t min_detections ƒë·ªÉ x√°c nh·∫≠n
        if len(history) < self.min_detections:
            return None
        
        # L·∫•y c√°c detection g·∫ßn ƒë√¢y
        recent_detections = list(history)[-self.min_detections:]
        
        # T√≠nh consistency
        occupied_count = sum(1 for d in recent_detections if d['occupied'])
        consistency = occupied_count / len(recent_detections)
        
        # X√°c ƒë·ªãnh tr·∫°ng th√°i m·ªõi d·ª±a tr√™n consistency
        new_state = None
        if consistency >= self.consistency_threshold:
            new_state = True  # Occupied
        elif consistency <= (1.0 - self.consistency_threshold):
            new_state = False  # Empty
        else:
            return None  # Kh√¥ng ƒë·ªß consistent ƒë·ªÉ x√°c nh·∫≠n
        
        # Ki·ªÉm tra xem c√≥ thay ƒë·ªïi so v·ªõi tr·∫°ng th√°i hi·ªán t·∫°i kh√¥ng
        current_state = self.confirmed_states.get(spot_id, None)
        
        if current_state != new_state:
            # C√≥ thay ƒë·ªïi tr·∫°ng th√°i
            self.confirmed_states[spot_id] = new_state
            self.state_timestamps[spot_id] = time.time()
            
            # L·∫•y th√¥ng tin xe g·∫ßn nh·∫•t
            latest_detection = recent_detections[-1]
            
            logger.info(f"üîÑ State change detected: {spot_id} -> {'OCCUPIED' if new_state else 'EMPTY'}")
            
            return {
                'spot_id': spot_id,
                'new_state': new_state,
                'previous_state': current_state,
                'car_id': latest_detection['car_id'] if new_state else None,
                'confidence': consistency,
                'detection_count': len(recent_detections),
                'timestamp': latest_detection['timestamp']
            }
        
        return None
    
    def get_confirmed_state(self, spot_id: str) -> bool:
        """
        L·∫•y tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n c·ªßa √¥ ƒë·ªó
        
        Args:
            spot_id (str): ID √¥ ƒë·ªó
            
        Returns:
            bool: True n·∫øu c√≥ xe, False n·∫øu tr·ªëng
        """
        with self.lock:
            return self.confirmed_states.get(spot_id, False)
    
    def get_state_duration(self, spot_id: str) -> float:
        """
        L·∫•y th·ªùi gian (gi√¢y) t·ª´ l·∫ßn thay ƒë·ªïi tr·∫°ng th√°i cu·ªëi c√πng
        
        Args:
            spot_id (str): ID √¥ ƒë·ªó
            
        Returns:
            float: Th·ªùi gian t√≠nh b·∫±ng gi√¢y
        """
        with self.lock:
            if spot_id in self.state_timestamps:
                return time.time() - self.state_timestamps[spot_id]
            return 0.0
    
    def get_detection_stats(self, spot_id: str) -> Dict[str, Any]:
        """
        L·∫•y th·ªëng k√™ ph√°t hi·ªán cho m·ªôt √¥ ƒë·ªó
        
        Args:
            spot_id (str): ID √¥ ƒë·ªó
            
        Returns:
            Dict: Th·ªëng k√™ chi ti·∫øt
                {
                    'total_detections': int,
                    'recent_occupied_ratio': float,
                    'confirmed_state': bool,
                    'state_duration': float,
                    'last_detection_time': float,
                    'confidence': float
                }
        """
        with self.lock:
            history = self.detection_history[spot_id]
            
            if not history:
                return {
                    'total_detections': 0,
                    'recent_occupied_ratio': 0.0,
                    'confirmed_state': False,
                    'state_duration': 0.0,
                    'last_detection_time': 0.0,
                    'confidence': 0.0
                }
            
            # T√≠nh to√°n c√°c th·ªëng k√™
            total_detections = len(history)
            recent_detections = list(history)[-self.min_detections:] if len(history) >= self.min_detections else list(history)
            
            occupied_count = sum(1 for d in recent_detections if d['occupied'])
            recent_occupied_ratio = occupied_count / len(recent_detections) if recent_detections else 0.0
            
            # T√≠nh confidence d·ª±a tr√™n consistency
            if len(recent_detections) >= self.min_detections:
                if recent_occupied_ratio >= self.consistency_threshold:
                    confidence = recent_occupied_ratio
                elif recent_occupied_ratio <= (1.0 - self.consistency_threshold):
                    confidence = 1.0 - recent_occupied_ratio
                else:
                    confidence = 0.5  # Kh√¥ng ch·∫Øc ch·∫Øn
            else:
                confidence = 0.0
            
            return {
                'total_detections': total_detections,
                'recent_occupied_ratio': recent_occupied_ratio,
                'confirmed_state': self.get_confirmed_state(spot_id),
                'state_duration': self.get_state_duration(spot_id),
                'last_detection_time': history[-1]['timestamp'],
                'confidence': confidence
            }
    
    def cleanup_old_states(self) -> int:
        """
        D·ªçn d·∫πp c√°c tr·∫°ng th√°i c≈© ƒë√£ timeout
        
        Returns:
            int: S·ªë l∆∞·ª£ng tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c d·ªçn d·∫πp
        """
        with self.lock:
            current_time = time.time()
            cleaned_count = 0
            
            # Danh s√°ch c√°c spot_id c·∫ßn x√≥a
            spots_to_remove = []
            
            for spot_id, timestamp in self.state_timestamps.items():
                if current_time - timestamp > self.state_timeout:
                    spots_to_remove.append(spot_id)
            
            # X√≥a c√°c tr·∫°ng th√°i c≈©
            for spot_id in spots_to_remove:
                self.confirmed_states.pop(spot_id, None)
                self.state_timestamps.pop(spot_id, None)
                # Gi·ªØ l·∫°i detection history ƒë·ªÉ tham kh·∫£o
                cleaned_count += 1
            
            if cleaned_count > 0:
                logger.info(f"üßπ Cleaned up {cleaned_count} old states")
            
            return cleaned_count
    
    def reset_spot_state(self, spot_id: str):
        """
        Reset tr·∫°ng th√°i c·ªßa m·ªôt √¥ ƒë·ªó c·ª• th·ªÉ
        
        Args:
            spot_id (str): ID √¥ ƒë·ªó c·∫ßn reset
        """
        with self.lock:
            self.detection_history[spot_id].clear()
            self.confirmed_states.pop(spot_id, None)
            self.state_timestamps.pop(spot_id, None)
            
            logger.info(f"üîÑ Reset state for spot: {spot_id}")
    
    def reset_all_states(self):
        """Reset t·∫•t c·∫£ tr·∫°ng th√°i"""
        with self.lock:
            self.detection_history.clear()
            self.confirmed_states.clear()
            self.state_timestamps.clear()
            
            logger.info("üîÑ Reset all states")
    
    def get_all_spots_status(self) -> Dict[str, Dict[str, Any]]:
        """
        L·∫•y tr·∫°ng th√°i c·ªßa t·∫•t c·∫£ c√°c √¥ ƒë·ªó
        
        Returns:
            Dict: spot_id -> status_dict
        """
        with self.lock:
            status = {}
            
            # L·∫•y t·∫•t c·∫£ spot_id t·ª´ c·∫£ confirmed_states v√† detection_history
            all_spot_ids = set(self.confirmed_states.keys()) | set(self.detection_history.keys())
            
            for spot_id in all_spot_ids:
                status[spot_id] = self.get_detection_stats(spot_id)
            
            return status
    
    def set_parameters(self, 
                      min_detections: Optional[int] = None,
                      consistency_threshold: Optional[float] = None,
                      state_timeout: Optional[int] = None):
        """
        C·∫≠p nh·∫≠t tham s·ªë c·ªßa state tracker
        
        Args:
            min_detections (int, optional): S·ªë l·∫ßn ph√°t hi·ªán t·ªëi thi·ªÉu
            consistency_threshold (float, optional): Ng∆∞·ª°ng consistency
            state_timeout (int, optional): Timeout cho tr·∫°ng th√°i (seconds)
        """
        with self.lock:
            if min_detections is not None:
                self.min_detections = min_detections
                logger.info(f"üîß Updated min_detections to {min_detections}")
            
            if consistency_threshold is not None:
                self.consistency_threshold = consistency_threshold
                logger.info(f"üîß Updated consistency_threshold to {consistency_threshold}")
            
            if state_timeout is not None:
                self.state_timeout = state_timeout
                logger.info(f"üîß Updated state_timeout to {state_timeout}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        L·∫•y th·ªëng k√™ t·ªïng quan c·ªßa state tracker
        
        Returns:
            Dict: Th·ªëng k√™ t·ªïng quan
                {
                    'total_spots_tracked': int,
                    'currently_occupied': int,
                    'total_state_changes': int,
                    'average_confidence': float,
                    'uptime_seconds': float
                }
        """
        with self.lock:
            total_spots = len(set(self.confirmed_states.keys()) | set(self.detection_history.keys()))
            currently_occupied = sum(1 for occupied in self.confirmed_states.values() if occupied)
            
            # T√≠nh average confidence t·ª´ t·∫•t c·∫£ spots
            confidences = []
            for spot_id in self.detection_history.keys():
                stats = self.get_detection_stats(spot_id)
                confidences.append(stats['confidence'])
            
            avg_confidence = sum(confidences) / len(confidences) if confidences else 0.0
            
            return {
                'total_spots_tracked': total_spots,
                'currently_occupied': currently_occupied,
                'occupancy_rate': (currently_occupied / total_spots * 100) if total_spots > 0 else 0.0,
                'average_confidence': avg_confidence,
                'parameters': {
                    'min_detections': self.min_detections,
                    'consistency_threshold': self.consistency_threshold,
                    'state_timeout': self.state_timeout
                }
            }